{"version":3,"sources":["../source/unpackXlsxFileNode.js"],"names":["unpackXlsxFile","input","sheet","entries","stream","createReadStream","Promise","resolve","reject","entryPromises","pipe","Parse","on","all","then","entry","key","path","contents","push","data","toString","autodrain"],"mappings":";;;;;kBAawBA,c;;AAbxB;;;;AACA;;;;AACA;;;;AAEA;;;;AAEA;;;;;;;AAOe,SAASA,cAAT,CAAwBC,KAAxB,QAA0C;AAAA,MAATC,KAAS,QAATA,KAAS;;AACvD;AACA;AACA;AACA,MAAMC,UAAU,EAAhB;;AAEA,MAAMC,SAASH,oCAA0BA,KAA1B,GAAkC,aAAGI,gBAAH,CAAoBJ,KAApB,CAAjD;;AAEA,SAAO,IAAIK,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,QAAMC,gBAAgB,EAAtB;;AAEAL,WACGM,IADH,CACQ,mBAAMC,KAAN,EADR,EAEGC,EAFH,CAEM,OAFN,EAEeJ,MAFf,EAGGI,EAHH,CAGM,OAHN,EAGe,YAAM;AACjBN,cAAQO,GAAR,CAAYJ,aAAZ,EAA2BK,IAA3B,CAAgC;AAAA,eAAMP,QAAQ,8CAAoBJ,OAApB,EAA6BD,KAA7B,CAAR,CAAN;AAAA,OAAhC;AACD,KALH,EAMGU,EANH,CAMM,OANN,EAMe,UAACG,KAAD,EAAW;AACtB,UAAMC,MAAM,0CAAgBD,MAAME,IAAtB,EAA4Bf,KAA5B,CAAZ;AACA,UAAIc,GAAJ,EAAS;AACP,YAAIE,WAAW,EAAf;AACAT,sBAAcU,IAAd,CAAmB,IAAIb,OAAJ,CAAY,UAACC,OAAD,EAAa;AAC1CQ,gBACGH,EADH,CACM,MADN,EACc;AAAA,mBAAQM,YAAYE,KAAKC,QAAL,EAApB;AAAA,WADd,EAEGT,EAFH,CAEM,KAFN,EAEa,YAAM;AACfT,oBAAQa,GAAR,IAAeE,QAAf;AACAX;AACD,WALH;AAMD,SAPkB,CAAnB;AAQD,OAVD,MAUO;AACLQ,cAAMO,SAAN;AACD;AACF,KArBH;AAsBD,GAzBM,CAAP;AA0BD","file":"unpackXlsxFileNode.js","sourcesContent":["import fs from 'fs'\r\nimport Stream from 'stream'\r\nimport unzip from 'unzipper'\r\n\r\nimport { getXlsxEntryKey, validateXlsxEntries } from './readXlsxFileHelpers'\r\n\r\n/**\r\n * Reads XLSX file in Node.js.\r\n * @param  {(string|Stream)} input - A Node.js readable stream or a path to a file.\r\n * @param  {object} options\r\n * @param  {string?} options.sheet - Excel document sheet to read. Defaults to `1`. Will only read this sheet and skip others.\r\n * @return {Promise} Resolves to an object holding XLSX file entries.\r\n */\r\nexport default function unpackXlsxFile(input, { sheet }) {\r\n  // XLSX file is a zip archive.\r\n  // The `entries` object stores the files\r\n  // and their contents from this XLSX zip archive.\r\n  const entries = {}\r\n\r\n  const stream = input instanceof Stream ? input : fs.createReadStream(input)\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const entryPromises = []\r\n\r\n    stream\r\n      .pipe(unzip.Parse())\r\n      .on('error', reject)\r\n      .on('close', () => {\r\n        Promise.all(entryPromises).then(() => resolve(validateXlsxEntries(entries, sheet)))\r\n      })\r\n      .on('entry', (entry) => {\r\n        const key = getXlsxEntryKey(entry.path, sheet)\r\n        if (key) {\r\n          let contents = ''\r\n          entryPromises.push(new Promise((resolve) => {\r\n            entry\r\n              .on('data', data => contents += data.toString())\r\n              .on('end', () => {\r\n                entries[key] = contents\r\n                resolve()\r\n              })\r\n          }))\r\n        } else {\r\n          entry.autodrain()\r\n        }\r\n      })\r\n  })\r\n}\r\n"]}