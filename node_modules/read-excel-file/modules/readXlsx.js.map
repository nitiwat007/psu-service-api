{"version":3,"sources":["../source/readXlsx.js"],"names":["namespaces","a","letters","readXlsx","entries","xml","options","rowMap","sheet","values","createDocument","valuesDoc","strings","select","map","string","_","textContent","join","error","console","cells","Cell","node","d","split","CellCoords","calculateDimensions","cols","column","rows","row","data","times","push","cell","value","type","parseInt","trim","length","dropEmptyRows","dropEmptyColumns","comparator","b","allRows","sort","allCols","minRow","maxRow","minCol","maxCol","n","action","i","colToInt","col","indexOf","coords","cellNode","getAttribute","j","empty","splice"],"mappings":"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","file":"readXlsx.js","sourcesContent":["const namespaces = {\r\n  a: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main'\r\n}\r\n\r\nconst letters = [\"\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\r\n\r\n/**\r\n * Reads an (unzipped) XLSX file structure into a 2D array of cells.\r\n * @param  {object} entries - A list of entries (files) inside XLSX file.\r\n * @return {string[][]} An array of rows, each row being an array of cells.\r\n */\r\nexport default function readXlsx(entries, xml, options = {}) {\r\n  const { rowMap } = options\r\n\r\n  let sheet\r\n  let values\r\n\r\n  try {\r\n    sheet = xml.createDocument(entries.sheet)\r\n    const valuesDoc = xml.createDocument(entries.strings)\r\n    values = xml.select(valuesDoc, null, '//a:si', namespaces)\r\n      .map(string => xml.select(valuesDoc, string, './/a:t[not(ancestor::a:rPh)]', namespaces).map(_ => _.textContent).join(''))\r\n  } catch (error) {\r\n    // Guards against malformed XLSX files.\r\n    console.error(error)\r\n    return []\r\n  }\r\n\r\n  const cells = xml.select(sheet, null, '/a:worksheet/a:sheetData/a:row/a:c', namespaces).map(node => Cell(node, sheet, xml))\r\n\r\n  let d = xml.select(sheet, null, '//a:dimension/@ref', namespaces)[0]\r\n  if (d) {\r\n    d = d.textContent.split(':').map(CellCoords)\r\n  } else {\r\n    d = calculateDimensions(cells)\r\n  }\r\n\r\n  const cols = d[1].column - d[0].column + 1\r\n  const rows = d[1].row - d[0].row + 1\r\n\r\n  const data = []\r\n\r\n  times(rows, () => {\r\n    const row = []\r\n    times(cols, () => row.push(null))\r\n    data.push(row)\r\n  })\r\n\r\n  for (const cell of cells) {\r\n    let value = cell.value\r\n\r\n    if (cell.type === 's') {\r\n      value = values[parseInt(value)]\r\n    }\r\n\r\n    // Convert empty values to `null`.\r\n    // `value` could still be `null` or `undefined`.\r\n    value = value && value.trim() || null\r\n\r\n    if (data[cell.row - d[0].row]) {\r\n      data[cell.row - d[0].row][cell.column - d[0].column] = value\r\n    }\r\n  }\r\n\r\n  if (data.length === 0) {\r\n    return []\r\n  }\r\n\r\n  return dropEmptyRows(dropEmptyColumns(data), rowMap)\r\n}\r\n\r\nfunction calculateDimensions (cells) {\r\n  const comparator = (a, b) => a - b\r\n  const allRows = cells.map(cell => cell.row).sort(comparator)\r\n  const allCols = cells.map(cell => cell.column).sort(comparator)\r\n  const minRow = allRows[0]\r\n  const maxRow = allRows[allRows.length - 1]\r\n  const minCol = allCols[0]\r\n  const maxCol = allCols[allCols.length - 1]\r\n\r\n  return [\r\n    { row: minRow, column: minCol },\r\n    { row: maxRow, column: maxCol }\r\n  ]\r\n}\r\n\r\nfunction times(n, action) {\r\n  let i = 0\r\n  while (i < n) {\r\n    action()\r\n    i++\r\n  }\r\n}\r\n\r\nfunction colToInt(col) {\r\n  col = col.trim().split('')\r\n\r\n  let n = 0;\r\n\r\n  for (let i = 0; i < col.length; i++) {\r\n    n *= 26\r\n    n += letters.indexOf(col[i])\r\n  }\r\n\r\n  return n\r\n}\r\n\r\nfunction CellCoords(coords) {\r\n  coords = coords.split(/(\\d+)/)\r\n  return {\r\n    row    : parseInt(coords[1]),\r\n    column : colToInt(coords[0])\r\n  }\r\n}\r\n\r\nfunction Cell(cellNode, sheet, xml) {\r\n  const coords = CellCoords(cellNode.getAttribute('r'))\r\n  const value = xml.select(sheet, cellNode, 'a:v', namespaces)[0]\r\n  return {\r\n    column : coords.column,\r\n    row    : coords.row,\r\n    // For `xpath` `value` can be `undefined` while for native `DOMParser` it's `null`.\r\n    value  : value && value.textContent,\r\n    type   : cellNode.getAttribute('t')\r\n  }\r\n}\r\n\r\nexport function dropEmptyRows(data, rowMap) {\r\n  // Fill in row map.\r\n  if (rowMap) {\r\n    let j = 0\r\n    while (j < data.length) {\r\n      rowMap[j] = j\r\n      j++\r\n    }\r\n  }\r\n  // Drop empty rows.\r\n  let i = data.length - 1\r\n  while (i >= 0) {\r\n    // Check if the row is empty.\r\n    let empty = true\r\n    for (const cell of data[i]) {\r\n      if (cell) {\r\n        empty = false\r\n        break\r\n      }\r\n    }\r\n    // Remove the empty row.\r\n    if (empty) {\r\n      data.splice(i, 1)\r\n      if (rowMap) {\r\n        rowMap.splice(i, 1)\r\n      }\r\n    }\r\n    i--\r\n  }\r\n  return data\r\n}\r\n\r\nfunction dropEmptyColumns(data) {\r\n  let i = data[0].length - 1\r\n  while (i >= 0) {\r\n    let empty = true\r\n    for (const row of data) {\r\n      if (row[i]) {\r\n        empty = false\r\n        break\r\n      }\r\n    }\r\n    if (empty) {\r\n      let j = 0;\r\n      while (j < data.length) {\r\n        data[j].splice(i, 1)\r\n        j++\r\n      }\r\n    }\r\n    i--\r\n  }\r\n  return data\r\n}"]}