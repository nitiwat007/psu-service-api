var namespaces = {
  a: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main'
};

var letters = ["", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];

/**
 * Reads an (unzipped) XLSX file structure into a 2D array of cells.
 * @param  {object} entries - A list of entries (files) inside XLSX file.
 * @return {string[][]} An array of rows, each row being an array of cells.
 */
export default function readXlsx(entries, xml) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var rowMap = options.rowMap;


  var sheet = void 0;
  var values = void 0;

  try {
    sheet = xml.createDocument(entries.sheet);
    var valuesDoc = xml.createDocument(entries.strings);
    values = xml.select(valuesDoc, null, '//a:si', namespaces).map(function (string) {
      return xml.select(valuesDoc, string, './/a:t[not(ancestor::a:rPh)]', namespaces).map(function (_) {
        return _.textContent;
      }).join('');
    });
  } catch (error) {
    // Guards against malformed XLSX files.
    console.error(error);
    return [];
  }

  var cells = xml.select(sheet, null, '/a:worksheet/a:sheetData/a:row/a:c', namespaces).map(function (node) {
    return Cell(node, sheet, xml);
  });

  var d = xml.select(sheet, null, '//a:dimension/@ref', namespaces)[0];
  if (d) {
    d = d.textContent.split(':').map(CellCoords);
  } else {
    d = calculateDimensions(cells);
  }

  var cols = d[1].column - d[0].column + 1;
  var rows = d[1].row - d[0].row + 1;

  var data = [];

  times(rows, function () {
    var row = [];
    times(cols, function () {
      return row.push(null);
    });
    data.push(row);
  });

  for (var _iterator = cells, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var cell = _ref;

    var value = cell.value;

    if (cell.type === 's') {
      value = values[parseInt(value)];
    }

    // Convert empty values to `null`.
    // `value` could still be `null` or `undefined`.
    value = value && value.trim() || null;

    if (data[cell.row - d[0].row]) {
      data[cell.row - d[0].row][cell.column - d[0].column] = value;
    }
  }

  if (data.length === 0) {
    return [];
  }

  return dropEmptyRows(dropEmptyColumns(data), rowMap);
}

function calculateDimensions(cells) {
  var comparator = function comparator(a, b) {
    return a - b;
  };
  var allRows = cells.map(function (cell) {
    return cell.row;
  }).sort(comparator);
  var allCols = cells.map(function (cell) {
    return cell.column;
  }).sort(comparator);
  var minRow = allRows[0];
  var maxRow = allRows[allRows.length - 1];
  var minCol = allCols[0];
  var maxCol = allCols[allCols.length - 1];

  return [{ row: minRow, column: minCol }, { row: maxRow, column: maxCol }];
}

function times(n, action) {
  var i = 0;
  while (i < n) {
    action();
    i++;
  }
}

function colToInt(col) {
  col = col.trim().split('');

  var n = 0;

  for (var i = 0; i < col.length; i++) {
    n *= 26;
    n += letters.indexOf(col[i]);
  }

  return n;
}

function CellCoords(coords) {
  coords = coords.split(/(\d+)/);
  return {
    row: parseInt(coords[1]),
    column: colToInt(coords[0])
  };
}

function Cell(cellNode, sheet, xml) {
  var coords = CellCoords(cellNode.getAttribute('r'));
  var value = xml.select(sheet, cellNode, 'a:v', namespaces)[0];
  return {
    column: coords.column,
    row: coords.row,
    // For `xpath` `value` can be `undefined` while for native `DOMParser` it's `null`.
    value: value && value.textContent,
    type: cellNode.getAttribute('t')
  };
}

export function dropEmptyRows(data, rowMap) {
  // Fill in row map.
  if (rowMap) {
    var j = 0;
    while (j < data.length) {
      rowMap[j] = j;
      j++;
    }
  }
  // Drop empty rows.
  var i = data.length - 1;
  while (i >= 0) {
    // Check if the row is empty.
    var empty = true;
    for (var _iterator2 = data[i], _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var cell = _ref2;

      if (cell) {
        empty = false;
        break;
      }
    }
    // Remove the empty row.
    if (empty) {
      data.splice(i, 1);
      if (rowMap) {
        rowMap.splice(i, 1);
      }
    }
    i--;
  }
  return data;
}

function dropEmptyColumns(data) {
  var i = data[0].length - 1;
  while (i >= 0) {
    var empty = true;
    for (var _iterator3 = data, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var row = _ref3;

      if (row[i]) {
        empty = false;
        break;
      }
    }
    if (empty) {
      var j = 0;
      while (j < data.length) {
        data[j].splice(i, 1);
        j++;
      }
    }
    i--;
  }
  return data;
}
//# sourceMappingURL=readXlsx.js.map