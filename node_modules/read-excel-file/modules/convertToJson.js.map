{"version":3,"sources":["../source/convertToJson.js"],"names":["parseDate","Integer","isInteger","URL","isURL","Email","isEmail","DEFAULT_OPTIONS","isColumnOriented","data","schema","options","rowMap","transpose","columns","results","errors","i","length","result","read","push","error","row","rows","rowIndex","object","key","schemaEntry","isNestedSchema","type","Array","isArray","rawValue","indexOf","undefined","value","notEmpty","array","parseArray","map","_value","parseValue","required","column","prop","Object","keys","parse","parseCustomValue","parseValueOfType","Error","JSON","stringify","validate","message","parsed","String","Number","isFinite","parseFloat","Date","parseInt","date","Boolean","name","getBlock","string","endCharacter","startIndex","substring","character","block","blocks","index","trim","_"],"mappings":"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","file":"convertToJson.js","sourcesContent":["import parseDate from './parseDate'\r\nimport Integer, { isInteger } from './types/Integer'\r\nimport URL, { isURL } from './types/URL'\r\nimport Email, { isEmail } from './types/Email'\r\n\r\nconst DEFAULT_OPTIONS = {\r\n  isColumnOriented: false\r\n}\r\n\r\n/**\r\n * Convert 2D array to nested objects.\r\n * If row oriented data, row 0 is dotted key names.\r\n * Column oriented data is transposed.\r\n * @param {string[][]} data - An array of rows, each row being an array of cells.\r\n * @param {object} schema\r\n * @return {object[]}\r\n */\r\nexport default function(data, schema, options) {\r\n  if (options) {\r\n    options = {\r\n      ...DEFAULT_OPTIONS,\r\n      ...options\r\n    }\r\n  } else {\r\n    options = DEFAULT_OPTIONS\r\n  }\r\n\r\n  const {\r\n    isColumnOriented,\r\n    rowMap\r\n  } = options;\r\n\r\n  if (isColumnOriented) {\r\n    data = transpose(data)\r\n  }\r\n\r\n  const columns = data[0]\r\n\r\n  const results = []\r\n  const errors = []\r\n\r\n  for (let i = 1; i < data.length; i++) {\r\n    const result = read(schema, data[i], i - 1, columns, errors)\r\n    if (result) {\r\n      results.push(result)\r\n    }\r\n  }\r\n\r\n  // Correct error rows.\r\n  if (rowMap) {\r\n    for (const error of errors) {\r\n      error.row = rowMap[error.row] + 1\r\n    }\r\n  }\r\n\r\n  return {\r\n    rows: results,\r\n    errors\r\n  }\r\n}\r\n\r\nfunction read(schema, row, rowIndex, columns, errors) {\r\n  const object = {}\r\n  for (const key of Object.keys(schema)) {\r\n    const schemaEntry = schema[key]\r\n    const isNestedSchema = typeof schemaEntry.type === 'object' && !Array.isArray(schemaEntry.type)\r\n    let rawValue = row[columns.indexOf(key)]\r\n    if (rawValue === undefined) {\r\n      rawValue = null\r\n    }\r\n    let value\r\n    let error\r\n    if (isNestedSchema) {\r\n      value = read(schemaEntry.type, row, rowIndex, columns, errors)\r\n    } else {\r\n      if (rawValue === null) {\r\n        value = null\r\n      }\r\n      else if (Array.isArray(schemaEntry.type)) {\r\n        let notEmpty = false\r\n        const array = parseArray(rawValue).map((_value) => {\r\n          const result = parseValue(_value, schemaEntry)\r\n          if (result.error) {\r\n            value = _value\r\n            error = result.error\r\n          }\r\n          if (result.value !== null) {\r\n            notEmpty = true\r\n          }\r\n          return result.value\r\n        })\r\n        if (!error) {\r\n          value = notEmpty ? array : null\r\n        }\r\n      } else {\r\n        const result = parseValue(rawValue, schemaEntry)\r\n        error = result.error\r\n        value = error ? rawValue : result.value\r\n      }\r\n    }\r\n    if (!error && value === null && schemaEntry.required) {\r\n      error = 'required'\r\n    }\r\n    if (error) {\r\n      error = {\r\n        error,\r\n        row: rowIndex + 1,\r\n        column: key,\r\n        value\r\n      }\r\n      if (schemaEntry.type) {\r\n        error.type = schemaEntry.type\r\n      }\r\n      errors.push(error)\r\n    } else if (value !== null) {\r\n      object[schemaEntry.prop] = value\r\n    }\r\n  }\r\n  if (Object.keys(object).length > 0) {\r\n    return object\r\n  }\r\n  return null\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {string} value\r\n * @param  {object} schemaEntry\r\n * @return {{ value: any, error: string }}\r\n */\r\nexport function parseValue(value, schemaEntry) {\r\n  if (value === null) {\r\n    return { value: null }\r\n  }\r\n  let result\r\n  if (schemaEntry.parse) {\r\n    result = parseCustomValue(value, schemaEntry.parse)\r\n  } else if (schemaEntry.type) {\r\n    result = parseValueOfType(value, Array.isArray(schemaEntry.type) ? schemaEntry.type[0] : schemaEntry.type)\r\n  } else {\r\n    throw new Error('Invalid schema entry: no .type and no .parse():\\n\\n' + JSON.stringify(schemaEntry, null, 2))\r\n  }\r\n  // If errored then return the error.\r\n  if (result.error) {\r\n    return result\r\n  }\r\n  if (result.value !== null && schemaEntry.validate) {\r\n    try {\r\n      schemaEntry.validate(result.value)\r\n    } catch (error) {\r\n      return { error: error.message }\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * Converts textual value to a custom value using supplied `.parse()`.\r\n * @param  {string} value\r\n * @param  {function} parse\r\n * @return {{ value: any, error: string }}\r\n */\r\nfunction parseCustomValue(value, parse) {\r\n  try {\r\n    let parsed = parse(value)\r\n    if (parsed === undefined) {\r\n      return { value: null }\r\n    }\r\n    return { value: parsed }\r\n  } catch (error) {\r\n    return { error: error.message }\r\n  }\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {string} value\r\n * @param  {} type\r\n * @return {{ value: (string|number|Date|boolean), error: string }}\r\n */\r\nfunction parseValueOfType(value, type) {\r\n  switch (type) {\r\n    case String:\r\n      return { value }\r\n\r\n    case Number:\r\n    case 'Integer':\r\n    case Integer:\r\n      // The global isFinite() function determines\r\n      // whether the passed value is a finite number.\r\n      // If  needed, the parameter is first converted to a number.\r\n      if (!isFinite(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      if (type === Integer && !isInteger(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      return { value: parseFloat(value) }\r\n\r\n    case 'URL':\r\n    case URL:\r\n      if (!isURL(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      return { value }\r\n\r\n    case 'Email':\r\n    case Email:\r\n      if (!isEmail(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      return { value }\r\n\r\n    case Date:\r\n      if (!isFinite(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      value = parseInt(value)\r\n      const date = parseDate(value)\r\n      if (!date) {\r\n        return { error: 'invalid' }\r\n      }\r\n      return { value: date }\r\n\r\n    case Boolean:\r\n      if (value === '1') {\r\n        return { value: true }\r\n      }\r\n      if (value === '0') {\r\n        return { value: false }\r\n      }\r\n      return { error: 'invalid' }\r\n\r\n    default:\r\n      throw new Error(`Unknown schema type: ${type && type.name || type}`)\r\n  }\r\n}\r\n\r\nexport function getBlock(string, endCharacter, startIndex) {\r\n  let i = 0\r\n  let substring = ''\r\n  let character\r\n  while (startIndex + i < string.length) {\r\n    const character = string[startIndex + i]\r\n    if (character === endCharacter) {\r\n      return [substring, i]\r\n    }\r\n    else if (character === '\"') {\r\n      const block = getBlock(string, '\"', startIndex + i + 1)\r\n      substring += block[0]\r\n      i += '\"'.length + block[1] + '\"'.length\r\n    }\r\n    else {\r\n      substring += character\r\n      i++\r\n    }\r\n  }\r\n  return [substring, i]\r\n}\r\n\r\nexport function parseArray(string) {\r\n  const blocks = []\r\n  let index = 0\r\n  while (index < string.length) {\r\n    const [substring, length] = getBlock(string, ',', index)\r\n    index += length + ','.length\r\n    blocks.push(substring.trim())\r\n  }\r\n  return blocks\r\n}\r\n\r\n// Transpose a 2D array.\r\n// https://stackoverflow.com/questions/17428587/transposing-a-2d-array-in-javascript\r\nconst transpose = array => array[0].map((_, i) => array.map(row => row[i]))"]}